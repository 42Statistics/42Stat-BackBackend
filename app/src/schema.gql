# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Coalition {
  id: Int!
  name: String!
  slug: String!
  imageUrl: String
  coverUrl: String
  color: String
  score: Int!

  """코알리숑 마스터의 user id 입니다."""
  userId: Int!
}

type UserTitle {
  titleId: Int!
  name: String!
  selected: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type UserProfile {
  id: Int!
  login: String!
  imgUrl: String
  grade: String!
  displayname: String!
  coalition: Coalition!
  titles: [UserTitle]!
  level: Float!
}

type UserPreview {
  id: Int!
  login: String!
  imgUrl: String
}

type UserRanking {
  userPreview: UserPreview!
  value: Float!
  rank: Int!
}

type UserRankingIndexPaginated {
  nodes: [UserRanking]!
  totalCount: Int!
  pageSize: Int!
  pageNumber: Int!
}

type ProjectPreview {
  id: Int!
  name: String!
  url: URL!
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

type CursorPageInfo {
  totalCount: Int!
  hasNextPage: Boolean!
  endCursor: String
}

type TeamPreview {
  id: Int!
  name: String!
  url: String!
}

type Flag {
  id: Int!
  name: String!
  isPositive: Boolean!
}

type EvalLogHeader {
  corrector: UserPreview!
  teamPreview: TeamPreview!
  beginAt: DateTime!
  projectPreview: ProjectPreview!
  flag: Flag!
}

type EvalReview {
  mark: Int!
  review: String!
}

type EvalLog {
  id: Int!
  header: EvalLogHeader!

  """평가자가 부여한 점수와 리뷰 입니다."""
  correctorReview: EvalReview!

  """피평가자가 부여한 점수와 리뷰 입니다."""
  correctedsReview: EvalReview!
}

type EvalLogEdge {
  cursor: String!
  node: EvalLog!
}

type EvalLogsPaginated {
  edges: [EvalLogEdge]!
  pageInfo: CursorPageInfo
}

type IntRecord {
  at: DateTime!
  value: Int!
}

type IntPerCoalition {
  coalition: Coalition!
  value: Int!
}

type ScoreRecordPerCoalition {
  coalition: Coalition!
  records: [IntRecord]!
}

type HomeCoalition {
  totalScoresPerCoalition: [IntPerCoalition!]!
  scoreRecordsPerCoalition: [ScoreRecordPerCoalition!]!
  tigCountPerCoalition: [IntPerCoalition!]!
}

type IntDateRanged {
  data: Int!
  start: DateTime!
  end: DateTime!
}

type FloatDateRanged {
  data: Float!
  start: DateTime!
  end: DateTime!
}

type HomeEval {
  totalEvalCount: Int!
  evalCountByDateTemplate(dateTemplate: DateTemplate!): IntDateRanged!
  averageEvalCountByDateTemplate(dateTemplate: DateTemplate!): FloatDateRanged!
  averageFeedbackLength: Int!
  averageCommentLength: Int!
}

enum DateTemplate {
  CURR_WEEK
  LAST_WEEK
  CURR_MONTH
  LAST_MONTH
  LAST_YEAR
}

type ProjectRanking {
  projectPreview: ProjectPreview!
  value: Int!
}

type ExamResult {
  rank: Int!
  passCount: Int!
  totalCount: Int!
}

type ExamResultDateRanged {
  data: [ExamResult!]!
  start: DateTime!
  end: DateTime!
}

type HomeTeam {
  currRegisteredCountRanking: [ProjectRanking!]!

  """HOME 직전 회차 시험 Rank별 통과율"""
  lastExamResult: ExamResultDateRanged!
}

type Pair {
  key: String!
  value: Int!
}

type Rate {
  total: Int!
  fields: [Pair!]!
}

type IntPerCircle {
  circle: Int!
  value: Int!
}

type UserCountPerLevel {
  userCount: Int!
  level: Int!
}

type HomeUser {
  activeUserCountRecords: [IntRecord!]!
  userCountPerLevel: [UserCountPerLevel!]!
  memberRate: Rate!
  blackholedRate: Rate!
  blackholedCountByDateTemplate(dateTemplate: DateTemplate!): IntDateRanged!
  blackholedCountPerCircle: [IntPerCircle!]!
  walletRanking(limit: Int! = 5): [UserRanking!]!
  correctionPointRanking(limit: Int! = 5): [UserRanking!]!
  averageDurationPerCircle: [IntPerCircle!]!
}

type LeaderboardElement {
  """내 랭킹 정보"""
  me: UserRanking

  """전체 랭킹 정보"""
  totalRanking: UserRankingIndexPaginated!
}

type LeaderboardElementDateRanged {
  data: LeaderboardElement!
  start: DateTime!
  end: DateTime!
}

type LeaderboardEval {
  total(pageSize: Int! = 10, pageNumber: Int! = 1): LeaderboardElement!
  byDateTemplate(pageSize: Int! = 10, pageNumber: Int! = 1, dateTemplate: DateTemplate!): LeaderboardElementDateRanged!
}

type LeaderboardExp {
  byDateTemplate(pageSize: Int! = 10, pageNumber: Int! = 1, dateTemplate: DateTemplate!): LeaderboardElementDateRanged!
}

type LeaderboardLevel {
  total(pageSize: Int! = 10, pageNumber: Int! = 1): LeaderboardElement!
}

type LeaderboardScore {
  total(pageSize: Int! = 10, pageNumber: Int! = 1): LeaderboardElement!
  byDateTemplate(pageSize: Int! = 10, pageNumber: Int! = 1, dateTemplate: DateTemplate!): LeaderboardElementDateRanged!
}

type PersonalEval {
  userProfile: UserProfile!
  correctionPoint: Int!
  totalCount: Int!
  countByDateTemplate(dateTemplate: DateTemplate!): IntDateRanged!
  totalDuration: Int!
  averageDuration: Int!
  averageFinalMark: Float!
  averageFeedbackLength: Int!
  averageCommentLength: Int!
  latestFeedback: String!
  evalLogSearchUrl: String!
  lastComment: String
}

type UserTeam {
  id: Int!
  name: String!
  occurrence: Int!
  projectPreview: ProjectPreview!
  status: TeamStatus!
  lastEventTime: DateTime!
  isValidated: Boolean
  finalMark: Int
}

enum TeamStatus {
  REGISTERED
  IN_PROGRESS
  WAITING_FOR_CORRECTION
  FINISHED
}

type PreferredTime {
  total: Int!

  """06 ~ 12"""
  morning: Int!

  """12 ~ 18"""
  daytime: Int!

  """18 ~ 24"""
  evening: Int!

  """24 ~ 06"""
  night: Int!
}

type PreferredTimeDateRanged {
  data: PreferredTime!
  start: DateTime!
  end: DateTime!
}

type PreferredCluster {
  name: String
}

type PreferredClusterDateRanged {
  data: PreferredCluster!
  start: DateTime!
  end: DateTime!
}

type TeamInfo {
  lastRegistered: String
  lastPassed: String
  teams: [UserTeam]!
}

type LevelRecord {
  after: Int!
  userLevel: Float!
  averageLevel: Float!
}

type UserScoreInfo {
  value: Int!
  rankInCoalition: Int!
  rankInTotal: Int!
}

type PersonalGeneral {
  userProfile: UserProfile!
  beginAt: DateTime!
  blackholedAt: DateTime
  wallet: Int!
  scoreInfo: UserScoreInfo!
  logtimeByDateTemplate(dateTemplate: DateTemplate!): IntDateRanged!
  preferredTimeByDateTemplate(dateTemplate: DateTemplate!): PreferredTimeDateRanged!
  preferredClusterByDateTemplate(dateTemplate: DateTemplate!): PreferredClusterDateRanged!
  teamInfo: TeamInfo!
  levelRecords: [LevelRecord!]!
}

type ProjectEvalInfo {
  totalEvalCount: Int!
  passCount: Int!
  failCount: Int!
}

type ProjectInfo {
  id: Int!
  name: String!
  skills: [String]!
  keywords: [String]!
  description: String!
  minUserCount: Int!
  maxUserCount: Int!
  duration: Int!
  difficulty: Int!
  currRegisteredTeamCount: Int!

  """총 제출 횟수 입니다."""
  closedTeamCount: Int!
  averagePassFinalMark: Int!
  evalInfo: ProjectEvalInfo!
}

type Query {
  findUserPreview(login: String! = "", limit: Int! = 10): [UserPreview]!
  findProjectPreview(name: String! = ""): [ProjectPreview]!
  getHomeUser: HomeUser!
  getHomeEval: HomeEval!
  getHomeCoalition: HomeCoalition!
  getHomeTeam: HomeTeam!
  getPersonalGeneralPage(login: String, userId: Int): PersonalGeneral!
  getPersonalEvalPage(userId: Int, login: String): PersonalEval!
  getProjectInfo(projectName: String! = "libft"): ProjectInfo!
  getLeaderboardLevel: LeaderboardLevel!
  getLeaderboardExpIncrement: LeaderboardExp!
  getLeaderboardEvalCount: LeaderboardEval!
  getLeaderboardScore: LeaderboardScore!
  getEvalLogs(after: String, first: Int!, corrector: String, corrected: String, projectName: String, outstandingOnly: Boolean! = false, sortOrder: EvalLogSortOrder! = BEGIN_AT_DESC): EvalLogsPaginated!
}

enum EvalLogSortOrder {
  BEGIN_AT_ASC
  BEGIN_AT_DESC
}